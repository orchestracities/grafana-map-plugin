{"version":3,"sources":["../../src/utils/data_utils.js"],"names":["DataFormatter","series","length","seriesType","_getSeriesType","_getSeries","_getSeriesTimeSeries","hashSeriesByLayerByKey","seriesLayer","id","forEach","series_elem","columns","map","elem","text","rows","series_elem_row","hashWithValues","i","push","setSeries","setSeriesByLayer","target","split","seriesFieldName","datapoints","Object","keys","layerName","superArray","column","result","line","type"],"mappings":"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","sourcesContent":["// import { isEqual, reduce, filter, transform, isObject } from 'lodash';\n\nclass DataFormatter {\n  getValues(series) {\n    if (!series || series.length === 0) return {};\n\n    const seriesType = this._getSeriesType(series);\n\n    return (seriesType === 'table') ? this._getSeries(series) : this._getSeriesTimeSeries(series);\n  }\n\n  _getSeries(series) {\n    const hashSeriesByLayerByKey = {};\n    let seriesLayer = null;\n    let id = null;\n\n    series.forEach((series_elem) => {\n      const columns = series_elem.columns.map((elem) => elem.text);\n\n      series_elem.rows.forEach((series_elem_row) => {\n        seriesLayer = series_elem_row[series_elem_row.length - 1];\n\n        if (!(hashSeriesByLayerByKey[seriesLayer])) {\n          hashSeriesByLayerByKey[seriesLayer] = {};\n        }\n\n        id = series_elem_row[1];\n        if (!(hashSeriesByLayerByKey[seriesLayer][id])) {\n          hashSeriesByLayerByKey[seriesLayer][id] = [];\n        }\n\n        const hashWithValues = {};\n        columns.forEach((elem, i) => {\n          if (i !== 0 && i !== columns.length - 1) // do not insert grafana field 'time' and the group by field\n          { hashWithValues[elem] = series_elem_row[i]; }\n        });\n        hashSeriesByLayerByKey[seriesLayer][id].push(hashWithValues);\n      });\n    });\n\n    return hashSeriesByLayerByKey;\n  }\n\n  _getSeriesTimeSeries(series) {\n    const setSeries = {};\n    const setSeriesByLayer = {};\n\n    series.forEach((series_elem) => {\n      const [seriesLayer, seriesFieldName] = series_elem.target.split(': ');\n\n      if (!(setSeriesByLayer[seriesLayer])) {\n        setSeriesByLayer[seriesLayer] = [];\n      }\n\n      setSeriesByLayer[seriesLayer].push([seriesFieldName, ...series_elem.datapoints.map((elem) => elem[0])]);\n    });\n\n\n    // get one array and transform into a hash\n    const hashSeriesByLayerByKey = {};\n\n    Object.keys(setSeriesByLayer).forEach((layerName) => {\n      if (!hashSeriesByLayerByKey[layerName]) hashSeriesByLayerByKey[layerName] = {};\n\n      const superArray = setSeriesByLayer[layerName];\n\n      for (let column = 1; column < superArray[0].length; column++) {\n        const result = {};\n        for (let line = 0; line < superArray.length; line++) {\n          result[superArray[line][0]] = superArray[line][column];\n        }\n\n        if (!hashSeriesByLayerByKey[layerName][result.id]) hashSeriesByLayerByKey[layerName][result.id] = [];\n\n        hashSeriesByLayerByKey[layerName][result.id].push(result);\n      }\n    });\n\n    return hashSeriesByLayerByKey;\n  }\n\n  _getSeriesType(series) {\n    return series[0].type;\n  }\n}\n\nexport { DataFormatter };\n"],"file":"data_utils.js"}